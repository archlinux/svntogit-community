#!/bin/bash

. /etc/rc.conf
. /etc/rc.d/functions
. /etc/conf.d/dkms


# list dkms modules for the current running kernel
list_dkms_modules() {
  shopt -s nullglob
  declare -a DKMS_MOULES
  # dkms status needs uname -r to list correctly intalled version for current kernel
  local modules_path=($(dkms status -k "$(uname -r)"|sed -rn 's#(.*), (.*), (.*), (.*): installed#\1/\2/\3/\4#p'))
  for p in "${modules_path[@]}"; do
    for m in /var/lib/dkms/"$p"/module/*.ko{,gz}; do
      m=${m##*/}
      m=${m%.gz}
      m=${m%.ko}
      DKMS_MODULES+=("$m")
    done
  done
}

# load installed kernel modules for the current kernel version
load_dkms_modules() {
  local ret=0
  list_dkms_modules
  for m in "${DKMS_MODULES[@]}"; do
    modprobe "$m"
    ret+=$?
  done
  return $ret
}

# unload installed kernel modules for the current kernel version
unload_dkms_modules() {
  list_dkms_modules
  # ask for removal
  for m in "${DKMS_MODULES[@]}"; do
    modprobe --remove --quiet "$m"
  done
  # check modules are unloaded
  # sometimes modprobe -r fail but modules are removed
  for m in "${DKMS_MODULES[@]}"; do
    [[ -e /sys/modules/$m ]] && return 1
  done
  return 0
}

case "$1" in
  start)
    status 'Starting DKMS autoinstall' dkms autoinstall -k "$(uname -r)" &&
      add_daemon ${0##*/} || exit 1
    [[ $LOAD =~ [Yy][Ee][Ss] ]] &&
      status -v 'Loading DKMS modules' load_dkms_modules
  ;;
  stop)
    if [[ $UNLOAD =~ [Yy][Ee][Ss] ]]; then
      status -v 'Unloading DKMS modules' unload_dkms_modules
    else
      status 'Stopping DKMS'
    fi
    rm_daemon ${0##*/}
  ;;
  *)
    echo "usage: ${0##*/} {start|stop}" >&2
  ;;
esac

:
# vim:set ts=2 sw=2 ft=sh et:
