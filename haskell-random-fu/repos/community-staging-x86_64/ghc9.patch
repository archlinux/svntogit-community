From 268e66b778157e64f508d9d2018f8252034cc14d Mon Sep 17 00:00:00 2001
From: Alexey Kuleshevich <alexey@kuleshevi.ch>
Date: Sat, 3 Apr 2021 23:20:22 +0300
Subject: [PATCH 1/3] Remove trailing whitespaces and switch to newer lts

---
 random-fu/src/Data/Random/Distribution.hs     |  40 +++----
 .../src/Data/Random/Distribution/Bernoulli.hs |  10 +-
 .../Data/Random/Distribution/Categorical.hs   |  52 ++++-----
 .../src/Data/Random/Distribution/Dirichlet.hs |   2 +-
 random-fu/src/Data/Random/Distribution/F.hs   |   1 -
 .../src/Data/Random/Distribution/Gamma.hs     |  13 ++-
 .../Data/Random/Distribution/Multinomial.hs   |   4 +-
 .../src/Data/Random/Distribution/Normal.hs    |  42 ++++----
 .../src/Data/Random/Distribution/Rayleigh.hs  |   4 +-
 .../Data/Random/Distribution/Triangular.hs    |   4 +-
 .../src/Data/Random/Distribution/Ziggurat.hs  | 100 +++++++++---------
 random-fu/src/Data/Random/Internal/Find.hs    |  16 +--
 random-fu/src/Data/Random/Internal/Fixed.hs   |   4 +-
 random-fu/src/Data/Random/Internal/TH.hs      |  27 +++--
 random-fu/src/Data/Random/Lift.hs             |   5 +-
 random-fu/src/Data/Random/List.hs             |   5 +-
 random-fu/src/Data/Random/RVar.hs             |   2 +-
 random-fu/src/Data/Random/Sample.hs           |   4 +-
 rvar/src/Data/RVar.hs                         |  58 +++++-----
 stack.yaml                                    |  10 +-
 tests/speed/Bench.hs                          |  16 +--
 tests/speed/speed-tests.cabal                 |   2 +-
 22 files changed, 210 insertions(+), 211 deletions(-)

diff --git a/random-fu/src/Data/Random/Distribution.hs b/random-fu/src/Data/Random/Distribution.hs
index 15ece3c..0c460f3 100644
--- a/random-fu/src/Data/Random/Distribution.hs
+++ b/random-fu/src/Data/Random/Distribution.hs
@@ -13,7 +13,7 @@ import Data.Random.RVar
 -- > data Normal a
 -- >     = StdNormal
 -- >     | Normal a a
--- 
+--
 -- Where the two parameters of the 'Normal' data constructor are the mean and
 -- standard deviation of the random variable, respectively.  To make use of
 -- the 'Normal' type, one can convert it to an 'rvar' and manipulate it or
@@ -21,39 +21,39 @@ import Data.Random.RVar
 --
 -- > x <- sample (rvar (Normal 10 2))
 -- > x <- sample (Normal 10 2)
--- 
+--
 -- A 'Distribution' is typically more transparent than an 'RVar'
--- but less composable (precisely because of that transparency).  There are 
+-- but less composable (precisely because of that transparency).  There are
 -- several practical uses for types implementing 'Distribution':
--- 
--- * Typically, a 'Distribution' will expose several parameters of a standard 
+--
+-- * Typically, a 'Distribution' will expose several parameters of a standard
 -- mathematical model of a probability distribution, such as mean and std deviation for
 -- the normal distribution.  Thus, they can be manipulated analytically using
 -- mathematical insights about the distributions they represent.  For example,
 -- a collection of bernoulli variables could be simplified into a (hopefully) smaller
 -- collection of binomial variables.
--- 
+--
 -- * Because they are generally just containers for parameters, they can be
--- easily serialized to persistent storage or read from user-supplied 
+-- easily serialized to persistent storage or read from user-supplied
 -- configurations (eg, initialization data for a simulation).
--- 
+--
 -- * If a type additionally implements the 'CDF' subclass, which extends
 -- 'Distribution' with a cumulative density function, an arbitrary random
 -- variable 'x' can be tested against the distribution by testing
 -- @fmap (cdf dist) x@ for uniformity.
--- 
+--
 -- On the other hand, most 'Distribution's will not be closed under all the
 -- same operations as 'RVar' (which, being a monad, has a fully turing-complete
--- internal computational model).  The sum of two uniformly-distributed 
--- variables, for example, is not uniformly distributed.  To support general 
--- composition, the 'Distribution' class defines a function 'rvar' to 
--- construct the more-abstract and more-composable 'RVar' representation 
+-- internal computational model).  The sum of two uniformly-distributed
+-- variables, for example, is not uniformly distributed.  To support general
+-- composition, the 'Distribution' class defines a function 'rvar' to
+-- construct the more-abstract and more-composable 'RVar' representation
 -- of a random variable.
 class Distribution d t where
     -- |Return a random variable with this distribution.
     rvar :: d t -> RVar t
     rvar = rvarT
-    
+
     -- |Return a random variable with the given distribution, pre-lifted to an arbitrary 'RVarT'.
     -- Any arbitrary 'RVar' can also be converted to an 'RVarT m' for an arbitrary 'm', using
     -- either 'lift' or 'sample'.
@@ -66,7 +66,7 @@ class Distribution d t => PDF d t where
     pdf d = exp . logPdf d
     logPdf :: d t -> t -> Double
     logPdf d = log . pdf d
-    
+
 
 class Distribution d t => CDF d t where
     -- |Return the cumulative distribution function of this distribution.
@@ -76,19 +76,19 @@ class Distribution d t => CDF d t where
     --
     -- In the case where 't' is an instance of Ord, 'cdf' should correspond
     -- to the CDF with respect to that order.
-    -- 
+    --
     -- In other cases, 'cdf' is only required to satisfy the following law:
     -- @fmap (cdf d) (rvar d)@
     -- must be uniformly distributed over (0,1).  Inclusion of either endpoint is optional,
     -- though the preferred range is (0,1].
-    -- 
-    -- Note that this definition requires that  'cdf' for a product type 
-    -- should _not_ be a joint CDF as commonly defined, as that definition 
+    --
+    -- Note that this definition requires that  'cdf' for a product type
+    -- should _not_ be a joint CDF as commonly defined, as that definition
     -- violates both conditions.
     -- Instead, it should be a univariate CDF over the product type.  That is,
     -- it should represent the CDF with respect to the lexicographic order
     -- of the product.
-    -- 
+    --
     -- The present specification is probably only really useful for testing
     -- conformance of a variable to its target distribution, and I am open to
     -- suggestions for more-useful specifications (especially with regard to
diff --git a/random-fu/src/Data/Random/Distribution/Bernoulli.hs b/random-fu/src/Data/Random/Distribution/Bernoulli.hs
index 446916a..1027fd8 100644
--- a/random-fu/src/Data/Random/Distribution/Bernoulli.hs
+++ b/random-fu/src/Data/Random/Distribution/Bernoulli.hs
@@ -57,7 +57,7 @@ generalBernoulliCDF gte f t p x
 
 newtype Bernoulli b a = Bernoulli b
 
-instance (Fractional b, Ord b, Distribution StdUniform b) 
+instance (Fractional b, Ord b, Distribution StdUniform b)
        => Distribution (Bernoulli b) Bool
     where
         rvarT (Bernoulli p) = boolBernoulli p
@@ -67,7 +67,7 @@ instance (Distribution (Bernoulli b) Bool, Real b)
         cdf  (Bernoulli p) = boolBernoulliCDF p
 
 $( replicateInstances ''Int integralTypes [d|
-        instance Distribution (Bernoulli b) Bool 
+        instance Distribution (Bernoulli b) Bool
               => Distribution (Bernoulli b) Int
               where
                   rvarT (Bernoulli p) = generalBernoulli 0 1 p
@@ -78,7 +78,7 @@ $( replicateInstances ''Int integralTypes [d|
     |] )
 
 $( replicateInstances ''Float realFloatTypes [d|
-        instance Distribution (Bernoulli b) Bool 
+        instance Distribution (Bernoulli b) Bool
               => Distribution (Bernoulli b) Float
               where
                   rvarT (Bernoulli p) = generalBernoulli 0 1 p
@@ -89,11 +89,11 @@ $( replicateInstances ''Float realFloatTypes [d|
     |] )
 
 instance (Distribution (Bernoulli b) Bool, Integral a)
-       => Distribution (Bernoulli b) (Ratio a)   
+       => Distribution (Bernoulli b) (Ratio a)
        where
            rvarT (Bernoulli p) = generalBernoulli 0 1 p
 instance (CDF (Bernoulli b) Bool, Integral a)
-       => CDF (Bernoulli b) (Ratio a)   
+       => CDF (Bernoulli b) (Ratio a)
        where
            cdf  (Bernoulli p) = generalBernoulliCDF (>=) 0 1 p
 instance (Distribution (Bernoulli b) Bool, RealFloat a)
diff --git a/random-fu/src/Data/Random/Distribution/Categorical.hs b/random-fu/src/Data/Random/Distribution/Categorical.hs
index 10051d1..575a0a2 100644
--- a/random-fu/src/Data/Random/Distribution/Categorical.hs
+++ b/random-fu/src/Data/Random/Distribution/Categorical.hs
@@ -37,7 +37,7 @@ import qualified Data.Vector.Mutable as MV
 categorical :: (Num p, Distribution (Categorical p) a) => [(p,a)] -> RVar a
 categorical = rvar . fromList
 
--- |Construct a 'Categorical' random process from a list of probabilities 
+-- |Construct a 'Categorical' random process from a list of probabilities
 -- and categories, where the probabilities all sum to 1.
 categoricalT :: (Num p, Distribution (Categorical p) a) => [(p,a)] -> RVarT m a
 categoricalT = rvarT . fromList
@@ -47,7 +47,7 @@ categoricalT = rvarT . fromList
 weightedCategorical :: (Fractional p, Eq p, Distribution (Categorical p) a) => [(p,a)] -> RVar a
 weightedCategorical = rvar . fromWeightedList
 
--- |Construct a 'Categorical' random process from a list of weights 
+-- |Construct a 'Categorical' random process from a list of weights
 -- and categories. The weights do /not/ have to sum to 1.
 weightedCategoricalT :: (Fractional p, Eq p, Distribution (Categorical p) a) => [(p,a)] -> RVarT m a
 weightedCategoricalT = rvarT . fromWeightedList
@@ -73,14 +73,14 @@ totalWeight (Categorical ds)
 numEvents :: Categorical p a -> Int
 numEvents (Categorical ds) = V.length ds
 
--- |Construct a 'Categorical' distribution from a list of weighted categories, 
+-- |Construct a 'Categorical' distribution from a list of weighted categories,
 -- where the weights do not necessarily sum to 1.
 fromWeightedList :: (Fractional p, Eq p) => [(p,a)] -> Categorical p a
 fromWeightedList = normalizeCategoricalPs . fromList
 
 -- |Construct a 'Categorical' distribution from a list of observed outcomes.
 -- Equivalent events will be grouped and counted, and the probabilities of each
--- event in the returned distribution will be proportional to the number of 
+-- event in the returned distribution will be proportional to the number of
 -- occurrences of that event.
 fromObservations :: (Fractional p, Eq p, Ord a) => [a] -> Categorical p a
 fromObservations = fromWeightedList . map (genericLength &&& head) . group . sort
@@ -91,10 +91,10 @@ fromObservations = fromWeightedList . map (genericLength &&& head) . group . sor
 -- binary search.
 
 -- |Categorical distribution; a list of events with corresponding probabilities.
--- The sum of the probabilities must be 1, and no event should have a zero 
+-- The sum of the probabilities must be 1, and no event should have a zero
 -- or negative probability (at least, at time of sampling; very clever users
--- can do what they want with the numbers before sampling, just make sure 
--- that if you're one of those clever ones, you at least eliminate negative 
+-- can do what they want with the numbers before sampling, just make sure
+-- that if you're one of those clever ones, you at least eliminate negative
 -- weights before sampling).
 newtype Categorical p a = Categorical (V.Vector (p, a))
     deriving Eq
@@ -117,19 +117,19 @@ instance (Fractional p, Ord p, Distribution Uniform p) => Distribution (Categori
         | n == 1    = return (snd (V.head ds))
         | otherwise = do
             u <- uniformT 0 (fst (V.last ds))
-            
+
             let -- by construction, p is monotone; (i < j) ==> (p i <= p j)
                 p i = fst (ds V.! i)
                 x i = snd (ds V.! i)
-                
+
                 --  findEvent
                 -- ===========
                 -- invariants: (i <= j), (u <= p j), ((i == 0) || (p i < u))
                 --  (the last one means 'i' does not increase unless it bounds 'p' below 'u')
                 -- variant: either i increases or j decreases.
                 -- upon termination: âˆ€ k. if (k < j) then (p k < u) else (u <= p k)
-                --  (that is, the chosen event 'x j' is the first one whose 
-                --   associated cumulative probability 'p j' is greater than 
+                --  (that is, the chosen event 'x j' is the first one whose
+                --   associated cumulative probability 'p j' is greater than
                 --   or equal to 'u')
                 findEvent i j
                     | j <= i    = x j
@@ -139,7 +139,7 @@ instance (Fractional p, Ord p, Distribution Uniform p) => Distribution (Categori
                         -- midpoint rounding down
                         -- (i < j) ==> (m < j)
                         m = (i + j) `div` 2
-            
+
             return $! if u <= 0 then x 0 else findEvent 0 (n-1)
         where n = V.length ds
 
@@ -156,22 +156,22 @@ instance Traversable (Categorical p) where
 
 instance Fractional p => Monad (Categorical p) where
     return x = Categorical (V.singleton (1, x))
-    
+
     -- I'm not entirely sure whether this is a valid form of failure; see next
     -- set of comments.
 #if __GLASGOW_HASKELL__ < 808
     fail _ = Categorical V.empty
 #endif
-    
+
     -- Should the normalize step be included here, or should normalization
     -- be assumed?  It seems like there is (at least) 1 valid situation where
-    -- non-normal results would arise:  the distribution being modeled is 
-    -- "conditional" and some event arose that contradicted the assumed 
-    -- condition and thus was eliminated ('f' returned an empty or 
+    -- non-normal results would arise:  the distribution being modeled is
+    -- "conditional" and some event arose that contradicted the assumed
+    -- condition and thus was eliminated ('f' returned an empty or
     -- zero-probability consequent, possibly by 'fail'ing).
-    -- 
+    --
     -- It seems reasonable to continue in such circumstances, but should there
-    -- be any renormalization?  If so, does it make a difference when that 
+    -- be any renormalization?  If so, does it make a difference when that
     -- renormalization is done?  I'm pretty sure it does, actually.  So, the
     -- normalization will be omitted here for now, as it's easier for the
     -- user (who really better know what they mean if they're returning
@@ -180,7 +180,7 @@ instance Fractional p => Monad (Categorical p) where
     xs >>= f = {- normalizeCategoricalPs . -} fromList $ do
         (p, x) <- toList xs
         (q, y) <- toList (f x)
-        
+
         return (p * q, y)
 
 instance Fractional p => Applicative (Categorical p) where
@@ -191,7 +191,7 @@ instance Fractional p => Applicative (Categorical p) where
 mapCategoricalPs :: (Num p, Num q) => (p -> q) -> Categorical p e -> Categorical q e
 mapCategoricalPs f = fromList . map (first f) . toList
 
--- |Adjust all the weights of a categorical distribution so that they 
+-- |Adjust all the weights of a categorical distribution so that they
 -- sum to unity and remove all events whose probability is zero.
 normalizeCategoricalPs :: (Fractional p, Eq p) => Categorical p e -> Categorical p e
 normalizeCategoricalPs orig@(Categorical ds)
@@ -200,13 +200,13 @@ normalizeCategoricalPs orig@(Categorical ds)
         lastP       <- newSTRef 0
         nDups       <- newSTRef 0
         normalized  <- V.thaw ds
-        
+
         let n           = V.length ds
             skip        = modifySTRef' nDups (1+)
             save i p x  = do
                 d <- readSTRef nDups
                 MV.write normalized (i-d) (p, x)
-        
+
         sequence_
             [ do
                 let (p,x) = ds V.! i
@@ -218,7 +218,7 @@ normalizeCategoricalPs orig@(Categorical ds)
                         writeSTRef lastP $! p
             | i <- [0..n-1]
             ]
-        
+
         -- force last element to 1
         d <- readSTRef nDups
         let n' = n-d
@@ -242,14 +242,14 @@ modifySTRef' x f = do
 -- event will have a probability equal to the sum of all the originals).
 collectEvents :: (Ord e, Num p, Ord p) => Categorical p e -> Categorical p e
 collectEvents = collectEventsBy compare ((sum *** head) . unzip)
-        
+
 -- |Simplify a categorical distribution by combining equivalent events (the new
 -- event will have a weight equal to the sum of all the originals).
 -- The comparator function is used to identify events to combine.  Once chosen,
 -- the events and their weights are combined by the provided probability and
 -- event aggregation function.
 collectEventsBy :: Num p => (e -> e -> Ordering) -> ([(p,e)] -> (p,e))-> Categorical p e -> Categorical p e
-collectEventsBy compareE combine = 
+collectEventsBy compareE combine =
     fromList . map combine . groupEvents . sortEvents . toList
     where
         groupEvents = groupBy (\x y -> snd x `compareE` snd y == EQ)
diff --git a/random-fu/src/Data/Random/Distribution/Dirichlet.hs b/random-fu/src/Data/Random/Distribution/Dirichlet.hs
index 3388ff8..7dbc4cc 100644
--- a/random-fu/src/Data/Random/Distribution/Dirichlet.hs
+++ b/random-fu/src/Data/Random/Distribution/Dirichlet.hs
@@ -18,7 +18,7 @@ fractionalDirichlet [_] = return [1]
 fractionalDirichlet as = do
     xs <- sequence [gammaT a 1 | a <- as]
     let total = foldl1' (+) xs
-    
+
     return (map (* recip total) xs)
 
 dirichlet :: Distribution Dirichlet [a] => [a] -> RVar [a]
diff --git a/random-fu/src/Data/Random/Distribution/Gamma.hs b/random-fu/src/Data/Random/Distribution/Gamma.hs
index ef89a44..bd27050 100644
--- a/random-fu/src/Data/Random/Distribution/Gamma.hs
+++ b/random-fu/src/Data/Random/Distribution/Gamma.hs
@@ -9,10 +9,10 @@
 module Data.Random.Distribution.Gamma
     ( Gamma(..)
     , gamma, gammaT
-    
+
     , Erlang(..)
     , erlang, erlangT
-    
+
     , mtGamma
     ) where
 
@@ -31,10 +31,10 @@ import Numeric.SpecFunctions
 {-# SPECIALIZE mtGamma :: Float  -> Float  -> RVarT m Float  #-}
 mtGamma
     :: (Floating a, Ord a,
-        Distribution StdUniform a, 
+        Distribution StdUniform a,
         Distribution Normal a)
     => a -> a -> RVarT m a
-mtGamma a b 
+mtGamma a b
     | a < 1     = do
         u <- stdUniformT
         mtGamma (1+a) $! (b * u ** recip a)
@@ -42,11 +42,11 @@ mtGamma a b
     where
         !d = a - fromRational (1%3)
         !c = recip (sqrt (9*d))
-        
+
         go = do
             x <- stdNormalT
             let !v   = 1 + c*x
-            
+
             if v <= 0
                 then go
                 else do
@@ -89,4 +89,3 @@ instance (Integral a, Floating b, Ord b, Distribution Normal b, Distribution Std
 
 instance (Integral a, Real b, Distribution (Erlang a) b) => CDF (Erlang a) b where
     cdf (Erlang a) x = incompleteGamma (fromIntegral a) (realToFrac x)
-
diff --git a/random-fu/src/Data/Random/Distribution/Multinomial.hs b/random-fu/src/Data/Random/Distribution/Multinomial.hs
index 6e8971a..af4c9fa 100644
--- a/random-fu/src/Data/Random/Distribution/Multinomial.hs
+++ b/random-fu/src/Data/Random/Distribution/Multinomial.hs
@@ -24,9 +24,9 @@ instance (Num a, Eq a, Fractional p, Distribution (Binomial p) a) => Distributio
             go n (p:ps) (psum:psums) f = do
                 x <- binomialT n (p / psum)
                 go (n-x) ps psums (f . (x:))
-            
+
             go _ _ _ _ = error "rvar/Multinomial: programming error! this case should be impossible!"
-            
+
             -- less wasteful version of (map sum . tails)
             tailSums [] = [0]
             tailSums (x:xs) = case tailSums xs of
diff --git a/random-fu/src/Data/Random/Distribution/Normal.hs b/random-fu/src/Data/Random/Distribution/Normal.hs
index 960414a..90b9e11 100644
--- a/random-fu/src/Data/Random/Distribution/Normal.hs
+++ b/random-fu/src/Data/Random/Distribution/Normal.hs
@@ -1,6 +1,6 @@
 {-# LANGUAGE
     MultiParamTypeClasses, FlexibleInstances, FlexibleContexts,
-    UndecidableInstances, ForeignFunctionInterface, BangPatterns, 
+    UndecidableInstances, ForeignFunctionInterface, BangPatterns,
     RankNTypes
   #-}
 
@@ -10,13 +10,13 @@ module Data.Random.Distribution.Normal
     ( Normal(..)
     , normal, normalT
     , stdNormal, stdNormalT
-    
+
     , doubleStdNormal
     , floatStdNormal
     , realFloatStdNormal
-    
+
     , normalTail
-    
+
     , normalPair
     , boxMullerNormalPair
     , knuthPolarNormalPair
@@ -44,7 +44,7 @@ normalPair = boxMullerNormalPair
 
 -- |A random variable that produces a pair of independent
 -- normally-distributed values, computed using the Box-Muller method.
--- This algorithm is slightly slower than Knuth's method but using a 
+-- This algorithm is slightly slower than Knuth's method but using a
 -- constant amount of entropy (Knuth's method is a rejection method).
 -- It is also slightly more general (Knuth's method require an 'Ord'
 -- instance).
@@ -55,27 +55,27 @@ boxMullerNormalPair = do
     t <- stdUniform
     let r = sqrt (-2 * log u)
         theta = (2 * pi) * t
-        
+
         x = r * cos theta
         y = r * sin theta
     return (x,y)
 
 -- |A random variable that produces a pair of independent
 -- normally-distributed values, computed using Knuth's polar method.
--- Slightly faster than 'boxMullerNormalPair' when it accepts on the 
+-- Slightly faster than 'boxMullerNormalPair' when it accepts on the
 -- first try, but does not always do so.
 {-# INLINE knuthPolarNormalPair #-}
 knuthPolarNormalPair :: (Floating a, Ord a, Distribution Uniform a) => RVar (a,a)
 knuthPolarNormalPair = do
     v1 <- uniform (-1) 1
     v2 <- uniform (-1) 1
-    
+
     let s = v1*v1 + v2*v2
     if s >= 1
         then knuthPolarNormalPair
         else return $ if s == 0
             then (0,0)
-            else let scale = sqrt (-2 * log s / s) 
+            else let scale = sqrt (-2 * log s / s)
                   in (v1 * scale, v2 * scale)
 
 -- |Draw from the tail of a normal distribution (the region beyond the provided value)
@@ -110,7 +110,7 @@ normalFInv :: Floating a => a -> a
 normalFInv y  = sqrt ((-2) * log y)
 -- | integral of 'normalF'
 normalFInt :: (Floating a, Erf a, Ord a) => a -> a
-normalFInt x 
+normalFInt x
     | x <= 0    = 0
     | otherwise = normalFVol * erf (x * sqrt 0.5)
 -- | volume of 'normalF'
@@ -120,8 +120,8 @@ normalFVol = sqrt (0.5 * pi)
 -- |A random variable sampling from the standard normal distribution
 -- over any 'RealFloat' type (subject to the rest of the constraints -
 -- it builds and uses a 'Ziggurat' internally, which requires the 'Erf'
--- class).  
--- 
+-- class).
+--
 -- Because it computes a 'Ziggurat', it is very expensive to use for
 -- just one evaluation, or even for multiple evaluations if not used and
 -- reused monomorphically (to enable the ziggurat table to be let-floated
@@ -135,10 +135,10 @@ normalFVol = sqrt (0.5 * pi)
 -- @Distribution Normal@ instance declaration.
 realFloatStdNormal :: (RealFloat a, Erf a, Distribution Uniform a) => RVarT m a
 realFloatStdNormal = runZiggurat (normalZ p getIU `asTypeOf` (undefined :: Ziggurat V.Vector a))
-    where 
+    where
         p :: Int
         p = 6
-        
+
         getIU :: (Num a, Distribution Uniform a) => RVarT m (Int, a)
         getIU = do
             i <- getRandomWord8
@@ -159,12 +159,12 @@ doubleStdNormalV = 2.4567663515413507e-3
 
 {-# NOINLINE doubleStdNormalZ #-}
 doubleStdNormalZ :: Ziggurat UV.Vector Double
-doubleStdNormalZ = mkZiggurat_ True 
-        normalF normalFInv 
-        doubleStdNormalC doubleStdNormalR doubleStdNormalV 
+doubleStdNormalZ = mkZiggurat_ True
+        normalF normalFInv
+        doubleStdNormalC doubleStdNormalR doubleStdNormalV
         getIU
         (normalTail doubleStdNormalR)
-    where 
+    where
         getIU :: RVarT m (Int, Double)
         getIU = do
             !w <- getRandomWord64
@@ -185,9 +185,9 @@ floatStdNormalV = 2.4567663515413507e-3
 
 {-# NOINLINE floatStdNormalZ #-}
 floatStdNormalZ :: Ziggurat UV.Vector Float
-floatStdNormalZ = mkZiggurat_ True 
-        normalF normalFInv 
-        floatStdNormalC floatStdNormalR floatStdNormalV 
+floatStdNormalZ = mkZiggurat_ True
+        normalF normalFInv
+        floatStdNormalC floatStdNormalR floatStdNormalV
         getIU
         (normalTail floatStdNormalR)
     where
diff --git a/random-fu/src/Data/Random/Distribution/Rayleigh.hs b/random-fu/src/Data/Random/Distribution/Rayleigh.hs
index c3d16a5..94ab61f 100644
--- a/random-fu/src/Data/Random/Distribution/Rayleigh.hs
+++ b/random-fu/src/Data/Random/Distribution/Rayleigh.hs
@@ -1,5 +1,5 @@
 {-# LANGUAGE
-        MultiParamTypeClasses, 
+        MultiParamTypeClasses,
         FlexibleInstances, FlexibleContexts,
         UndecidableInstances
   #-}
@@ -19,7 +19,7 @@ floatingRayleigh s = do
 
 -- |The rayleigh distribution with a specified mode (\"sigma\") parameter.
 -- Its mean will be @sigma*sqrt(pi/2)@ and its variance will be @sigma^2*(4-pi)/2@
--- 
+--
 -- (therefore if you want one with a particular mean @m@, @sigma@ should be @m*sqrt(2/pi)@)
 newtype Rayleigh a = Rayleigh a
 
diff --git a/random-fu/src/Data/Random/Distribution/Triangular.hs b/random-fu/src/Data/Random/Distribution/Triangular.hs
index 4653f39..272c5a7 100644
--- a/random-fu/src/Data/Random/Distribution/Triangular.hs
+++ b/random-fu/src/Data/Random/Distribution/Triangular.hs
@@ -52,8 +52,8 @@ triangularCDF a b c x
     = realToFrac (1 - (c - x)^(2 :: Int) / ((c - a) * (c - b)))
     | otherwise
     = 1
-    
+
 instance (RealFloat a, Ord a, Distribution StdUniform a) => Distribution Triangular a where
     rvarT (Triangular a b c) = floatingTriangular a b c
 instance (RealFrac a, Distribution Triangular a) => CDF Triangular a where
-    cdf  (Triangular a b c) = triangularCDF a b c
\ No newline at end of file
+    cdf  (Triangular a b c) = triangularCDF a b c
diff --git a/random-fu/src/Data/Random/Distribution/Ziggurat.hs b/random-fu/src/Data/Random/Distribution/Ziggurat.hs
index ca0e3e9..3d680d6 100644
--- a/random-fu/src/Data/Random/Distribution/Ziggurat.hs
+++ b/random-fu/src/Data/Random/Distribution/Ziggurat.hs
@@ -7,16 +7,16 @@
 
 -- |A generic \"ziggurat algorithm\" implementation.  Fairly rough right
 --  now.
---  
+--
 --  There is a lot of room for improvement in 'findBin0' especially.
 --  It needs a fair amount of cleanup and elimination of redundant
 --  calculation, as well as either a justification for using the simple
---  'findMinFrom' or a proper root-finding algorithm. 
---  
---  It would also be nice to add (preferably by pulling in an 
---  external package) support for numerical integration and 
---  differentiation, so that tables can be derived from only a 
---  PDF (if the end user is willing to take the performance and 
+--  'findMinFrom' or a proper root-finding algorithm.
+--
+--  It would also be nice to add (preferably by pulling in an
+--  external package) support for numerical integration and
+--  differentiation, so that tables can be derived from only a
+--  PDF (if the end user is willing to take the performance and
 --  accuracy hit for the convenience).
 module Data.Random.Distribution.Ziggurat
     ( Ziggurat(..)
@@ -48,10 +48,10 @@ import qualified Data.Vector.Unboxed as UV
 data Ziggurat v t = Ziggurat {
         -- |The X locations of each bin in the distribution.  Bin 0 is the
         -- 'infinite' one.
-        -- 
+        --
         -- In the case of bin 0, the value given is sort of magical - x[0] is
-        -- defined to be V/f(R).  It's not actually the location of any bin, 
-        -- but a value computed to make the algorithm more concise and slightly 
+        -- defined to be V/f(R).  It's not actually the location of any bin,
+        -- but a value computed to make the algorithm more concise and slightly
         -- faster by not needing to specially-handle bin 0 quite as often.
         -- If you really need to know why it works, see the 'runZiggurat'
         -- source or \"the literature\" - it's a fairly standard setup.
@@ -64,8 +64,8 @@ data Ziggurat v t = Ziggurat {
         --
         --  * a bin index, uniform over [0,c) :: Int (where @c@ is the
         --    number of bins in the tables)
-        -- 
-        --  * a uniformly distributed fractional value, from -1 to 1 
+        --
+        --  * a uniformly distributed fractional value, from -1 to 1
         --    if not mirrored, from 0 to 1 otherwise.
         --
         -- This is provided as a single 'RVar' because it can be implemented
@@ -74,21 +74,21 @@ data Ziggurat v t = Ziggurat {
         -- a double (using 52 bits) and a bin number (using up to 12 bits),
         -- for example.
         zGetIU            :: !(forall m. RVarT m (Int, t)),
-        
+
         -- |The distribution for the final \"virtual\" bin
         -- (the ziggurat algorithm does not handle distributions
         -- that wander off to infinity, so another distribution is needed
         -- to handle the last \"bin\" that stretches to infinity)
         zTailDist         :: (forall m. RVarT m t),
-        
+
         -- |A copy of the uniform RVar generator for the base type,
         -- so that @Distribution Uniform t@ is not needed when sampling
         -- from a Ziggurat (makes it a bit more self-contained).
         zUniform          :: !(forall m. t -> t -> RVarT m t),
-        
+
         -- |The (one-sided antitone) PDF, not necessarily normalized
         zFunc             :: !(t -> t),
-        
+
         -- |A flag indicating whether the distribution should be
         -- mirrored about the origin (the ziggurat algorithm in
         -- its native form only samples from one-sided distributions.
@@ -113,7 +113,7 @@ runZiggurat !Ziggurat{..} = go
             -- (or 0 to 1 if not mirroring the distribution).
             -- Let X be U scaled to the size of the selected bin.
             (!i,!u) <- zGetIU
-            
+
             -- if the uniform value U falls in the area "clearly inside" the
             -- bin, accept X immediately.
             -- Otherwise, depending on the bin selected, use either the
@@ -123,7 +123,7 @@ runZiggurat !Ziggurat{..} = go
                 else if i == 0
                     then sampleTail u
                     else sampleGreyArea i $! (u * zTable_xs ! i)
-        
+
         -- when the sample falls in the "grey area" (the area between
         -- the Y values of the selected bin and the bin after that one),
         -- use an accept/reject method based on the target PDF.
@@ -133,7 +133,7 @@ runZiggurat !Ziggurat{..} = go
             if v < zFunc (abs x)
                 then return $! x
                 else go
-        
+
         -- if the selected bin is the "infinite" one, call it quits and
         -- defer to the tail distribution (mirroring if needed to ensure
         -- the result has the sign already selected by zGetIU)
@@ -143,28 +143,28 @@ runZiggurat !Ziggurat{..} = go
             | otherwise         = zTailDist
 
 
--- |Build the tables to implement the \"ziggurat algorithm\" devised by 
+-- |Build the tables to implement the \"ziggurat algorithm\" devised by
 -- Marsaglia & Tang, attempting to automatically compute the R and V
 -- values.
--- 
+--
 -- Arguments:
--- 
+--
 --  * flag indicating whether to mirror the distribution
--- 
+--
 --  * the (one-sided antitone) PDF, not necessarily normalized
--- 
+--
 --  * the inverse of the PDF
--- 
+--
 --  * the number of bins
--- 
+--
 --  * R, the x value of the first bin
--- 
+--
 --  * V, the volume of each bin
--- 
+--
 --  * an RVar providing the 'zGetIU' random tuple
--- 
+--
 --  * an RVar sampling from the tail (the region where x > R)
--- 
+--
 {-# INLINE mkZiggurat_ #-}
 {-# SPECIALIZE mkZiggurat_ :: Bool -> (Float  ->  Float) -> (Float  ->  Float) -> Int -> Float  -> Float  -> (forall m. RVarT m (Int,  Float)) -> (forall m. RVarT m Float ) -> Ziggurat UV.Vector Float #-}
 {-# SPECIALIZE mkZiggurat_ :: Bool -> (Double -> Double) -> (Double -> Double) -> Int -> Double -> Double -> (forall m. RVarT m (Int, Double)) -> (forall m. RVarT m Double) -> Ziggurat UV.Vector Double #-}
@@ -191,13 +191,13 @@ mkZiggurat_ m f fInv c r v getIU tailDist = Ziggurat
     , zTailDist         = tailDist
     , zMirror           = m
     }
-    where 
+    where
         xs = zigguratTable f fInv c r v
 
--- |Build the tables to implement the \"ziggurat algorithm\" devised by 
+-- |Build the tables to implement the \"ziggurat algorithm\" devised by
 -- Marsaglia & Tang, attempting to automatically compute the R and V
 -- values.
--- 
+--
 -- Arguments are the same as for 'mkZigguratRec', with an additional
 -- argument for the tail distribution as a function of the selected
 -- R value.
@@ -213,15 +213,15 @@ mkZiggurat :: (RealFloat t, Vector v t,
               -> (forall m. t -> RVarT m t)
               -> Ziggurat v t
 mkZiggurat m f fInv fInt fVol c getIU tailDist =
-    mkZiggurat_ m f fInv c r v getIU (tailDist r) 
+    mkZiggurat_ m f fInv c r v getIU (tailDist r)
         where
             (r,v) = findBin0 c f fInv fInt fVol
 
 -- |Build a lazy recursive ziggurat.  Uses a lazily-constructed ziggurat
 -- as its tail distribution (with another as its tail, ad nauseam).
--- 
+--
 -- Arguments:
--- 
+--
 --  * flag indicating whether to mirror the distribution
 --
 --  * the (one-sided antitone) PDF, not necessarily normalized
@@ -254,7 +254,7 @@ mkZigguratRec m f fInv fInt fVol c getIU = z
             fix g = g (fix g)
             z = mkZiggurat m f fInv fInt fVol c getIU (fix (mkTail m f fInv fInt fVol c getIU z))
 
-mkTail :: 
+mkTail ::
     (RealFloat a, Vector v a, Distribution Uniform a) =>
     Bool
     -> (a -> a) -> (a -> a) -> (a -> a)
@@ -269,15 +269,15 @@ mkTail m f fInv fInt fVol c getIU typeRep nextTail r = do
      return (x + r * signum x)
         where
             fIntR = fInt r
-            
+
             f' x    | x < 0     = f r
                     | otherwise = f (x+r)
             fInv' = subtract r . fInv
             fInt' x | x < 0     = 0
                     | otherwise = fInt (x+r) - fIntR
-            
+
             fVol' = fVol - fIntR
-        
+
 
 zigguratTable :: (Fractional a, Vector v a, Ord a) =>
                  (a -> a) -> (a -> a) -> Int -> a -> a -> v a
@@ -292,17 +292,17 @@ zigguratXs f fInv c r v = (xs, excess)
     where
         xs = Prelude.map x [0..c] -- sample c x
         ys = Prelude.map f xs
-        
+
         x 0 = v / f r
         x 1 = r
         x i | i == c = 0
         x i | i >  1 = next (i-1)
         x _ = error "zigguratXs: programming error! this case should be impossible!"
-        
+
         next i = let x_i = xs!!i
                   in if x_i <= 0 then -1 else fInv (ys!!i + (v / x_i))
-        
-        excess = xs!!(c-1) * (f 0 - ys !! (c-1)) - v 
+
+        excess = xs!!(c-1) * (f 0 - ys !! (c-1)) - v
 
 
 precomputeRatios :: (Vector v a, Fractional a) => v a -> v a
@@ -314,7 +314,7 @@ precomputeRatios zTable_xs = generate (c-1) $ \i -> zTable_xs!(i+1) / zTable_xs!
 -- Search the distribution for an appropriate R and V.
 --
 -- Arguments:
--- 
+--
 --  * Number of bins
 --
 --  * target function (one-sided antitone PDF, not necessarily normalized)
@@ -326,20 +326,20 @@ precomputeRatios zTable_xs = generate (c-1) $ \i -> zTable_xs!(i+1) / zTable_xs!
 --  * estimate of total volume under function (integral from 0 to infinity)
 --
 -- Result: (R,V)
-findBin0 :: (RealFloat b) => 
+findBin0 :: (RealFloat b) =>
     Int -> (b -> b) -> (b -> b) -> (b -> b) -> b -> (b, b)
 findBin0 cInt f fInv fInt fVol = (rMin,v rMin)
     where
         c = fromIntegral cInt
         v r = r * f r + fVol - fInt r
-        
+
         -- initial R guess:
         r0 = findMin (\r -> v r <= fVol / c)
         -- find a better R:
-        rMin = findMinFrom r0 1 $ \r -> 
-            let e = exc r 
+        rMin = findMinFrom r0 1 $ \r ->
+            let e = exc r
              in e >= 0 && not (isNaN e)
-        
+
         exc x = zigguratExcess f fInv cInt x (v x)
 
 instance (Num t, Ord t, Vector v t) => Distribution (Ziggurat v) t where
diff --git a/random-fu/src/Data/Random/Internal/Find.hs b/random-fu/src/Data/Random/Internal/Find.hs
index 2c61f0e..c14c576 100644
--- a/random-fu/src/Data/Random/Internal/Find.hs
+++ b/random-fu/src/Data/Random/Internal/Find.hs
@@ -19,7 +19,7 @@ findMin = findMinFrom 0 1
 -- specified point with the specified stepsize, performs an exponential
 -- search out from there until it finds an interval bracketing the
 -- change-point of the predicate, and then performs a bisection search
--- to isolate the change point.  Note that infinitely-divisible domains 
+-- to isolate the change point.  Note that infinitely-divisible domains
 -- such as 'Rational' cannot be searched by this function because it does
 -- not terminate until it reaches a point where further subdivision of the
 -- interval has no effect.
@@ -33,31 +33,31 @@ findMinFrom z0 step1 p
         -- a feasible answer
         fixZero 0 = 0
         fixZero z = z
-        
+
         -- preconditions:
         -- not (p l)
         -- 0 <= l < x
-        ascend l x 
+        ascend l x
             | p x       = bisect l x
             | otherwise = ascend x $! 2*x-z0
-        
+
         -- preconditions:
         -- p h
         -- x < h <= 0
-        descend x h 
+        descend x h
             | p x       = (descend $! 2*x-z0) x
             | otherwise = bisect x h
-        
+
         -- preconditions:
         -- not (p l)
         -- p h
         -- l <= h
-        bisect l h 
+        bisect l h
             | l /< h    = h
             | l /< mid || mid /< h
             = if p mid then mid else h
             | p mid     = bisect l mid
             | otherwise = bisect mid h
-            where 
+            where
                 a /< b = not (a < b)
                 mid = (l+h)*0.5
diff --git a/random-fu/src/Data/Random/Internal/Fixed.hs b/random-fu/src/Data/Random/Internal/Fixed.hs
index 758dca4..5180203 100644
--- a/random-fu/src/Data/Random/Internal/Fixed.hs
+++ b/random-fu/src/Data/Random/Internal/Fixed.hs
@@ -35,10 +35,10 @@ resolutionOf2 x = resolution (res x)
 -- |The 'Fixed' type doesn't expose its constructors, but I need a way to
 -- convert them to and from their raw representation in order to sample
 -- them.  As long as 'Fixed' is a newtype wrapping 'Integer', 'mkFixed' and
--- 'unMkFixed' as defined here will work.  Both are implemented using 
+-- 'unMkFixed' as defined here will work.  Both are implemented using
 -- 'unsafeCoerce'.
 mkFixed :: Integer -> Fixed r
 mkFixed = unsafeCoerce
 
 unMkFixed :: Fixed r -> Integer
-unMkFixed = unsafeCoerce
\ No newline at end of file
+unMkFixed = unsafeCoerce
diff --git a/random-fu/src/Data/Random/Internal/TH.hs b/random-fu/src/Data/Random/Internal/TH.hs
index 7f28658..500b75b 100644
--- a/random-fu/src/Data/Random/Internal/TH.hs
+++ b/random-fu/src/Data/Random/Internal/TH.hs
@@ -6,12 +6,12 @@
 -- to cover large numbers of types.  I'm doing that rather than using
 -- class contexts because most Distribution instances need to cover
 -- multiple classes (such as Enum, Integral and Fractional) and that
--- can't be done easily because of overlap.  
--- 
--- I experimented a bit with a convoluted type-level classification 
--- scheme, but I think this is simpler and easier to understand.  It 
--- makes the haddock docs more cluttered because of the combinatorial 
--- explosion of instances, but overall I think it's just more sane than 
+-- can't be done easily because of overlap.
+--
+-- I experimented a bit with a convoluted type-level classification
+-- scheme, but I think this is simpler and easier to understand.  It
+-- makes the haddock docs more cluttered because of the combinatorial
+-- explosion of instances, but overall I think it's just more sane than
 -- anything else I've come up with yet.
 module Data.Random.Internal.TH
     ( replicateInstances
@@ -27,7 +27,7 @@ import Control.Monad
 
 -- |Names of standard 'Integral' types
 integralTypes :: [Name]
-integralTypes = 
+integralTypes =
     [ ''Integer
     , ''Int,  ''Int8,  ''Int16,  ''Int32,  ''Int64
     , ''Word, ''Word8, ''Word16, ''Word32, ''Word64
@@ -53,17 +53,17 @@ replaceName x y z
 -- 'Dec's in @decls@ and substitute every instance of the 'Name' @standin@ with
 -- each 'Name' in @types@, producing one copy of the 'Dec's in @decls@ for every
 -- 'Name' in @types@.
--- 
+--
 -- For example, 'Data.Random.Distribution.Uniform' has the following bit of TH code:
--- 
+--
 -- @ $( replicateInstances ''Int integralTypes [d|                                                  @
--- 
+--
 -- @       instance Distribution Uniform Int   where rvar (Uniform a b) = integralUniform a b       @
--- 
+--
 -- @       instance CDF Uniform Int            where cdf  (Uniform a b) = integralUniformCDF a b    @
--- 
+--
 -- @   |])                                                                                          @
--- 
+--
 -- This code takes those 2 instance declarations and creates identical ones for
 -- every type named in 'integralTypes'.
 replicateInstances :: (Monad m, Data t) => Name -> [Name] -> m [t] -> m [t]
@@ -76,4 +76,3 @@ replicateInstances standin types getDecls = liftM concat $ sequence
             ]
     | t <- types
     ]
-
diff --git a/random-fu/src/Data/Random/Lift.hs b/random-fu/src/Data/Random/Lift.hs
index f148cb1..658ac72 100644
--- a/random-fu/src/Data/Random/Lift.hs
+++ b/random-fu/src/Data/Random/Lift.hs
@@ -19,10 +19,10 @@ import qualified Control.Monad.Identity as MTL
 -- For instances where 'm' and 'n' have 'return'/'pure' defined,
 -- these instances must satisfy
 -- @lift (return x) == return x@.
--- 
+--
 -- This form of 'lift' has an extremely general type and is used primarily to
 -- support 'sample'.  Its excessive generality is the main reason it's not
--- exported from "Data.Random".  'RVarT' is, however, an instance of 
+-- exported from "Data.Random".  'RVarT' is, however, an instance of
 -- 'T.MonadTrans', which in most cases is the preferred way
 -- to do the lifting.
 class Lift m n where
@@ -67,4 +67,3 @@ instance T.MonadTrans t => Lift MTL.Identity (t MTL.Identity) where
     lift = T.lift
 
 #endif
-
diff --git a/random-fu/src/Data/Random/List.hs b/random-fu/src/Data/Random/List.hs
index 2398e9c..1770fac 100644
--- a/random-fu/src/Data/Random/List.hs
+++ b/random-fu/src/Data/Random/List.hs
@@ -28,11 +28,11 @@ shuffleT :: [a] -> RVarT m [a]
 shuffleT [] = return []
 shuffleT xs = do
     is <- zipWithM (\_ i -> uniformT 0 i) (tail xs) [1..]
-    
+
     return (SRS.shuffle xs (reverse is))
 
 -- | A random variable that shuffles a list of a known length (or a list
--- prefix of the specified length). Useful for shuffling large lists when 
+-- prefix of the specified length). Useful for shuffling large lists when
 -- the length is known in advance.  Avoids needing to traverse the list to
 -- discover its length.  Each ordering has equal probability.
 shuffleN :: Int -> [a] -> RVar [a]
@@ -53,4 +53,3 @@ shuffleNofMT n m xs
         is <- sequence [uniformT 0 i | i <- take n [m-1, m-2 ..1]]
         return (take n $ SRS.shuffle (take m xs) is)
 shuffleNofMT _ _ _ = error "shuffleNofMT: negative length specified"
-
diff --git a/random-fu/src/Data/Random/RVar.hs b/random-fu/src/Data/Random/RVar.hs
index 9ad0492..1e69672 100644
--- a/random-fu/src/Data/Random/RVar.hs
+++ b/random-fu/src/Data/Random/RVar.hs
@@ -8,7 +8,7 @@ import Data.Random.Lift
 import Data.Random.Internal.Source
 import Data.RVar hiding (runRVarT)
 
--- |Like 'runRVarTWith', but using an implicit lifting (provided by the 
+-- |Like 'runRVarTWith', but using an implicit lifting (provided by the
 -- 'Lift' class)
 runRVarT :: (Lift n m, RandomSource m s) => RVarT n a -> s -> m a
 runRVarT = runRVarTWith lift
diff --git a/random-fu/src/Data/Random/Sample.hs b/random-fu/src/Data/Random/Sample.hs
index 31069db..c1c730c 100644
--- a/random-fu/src/Data/Random/Sample.hs
+++ b/random-fu/src/Data/Random/Sample.hs
@@ -1,6 +1,6 @@
 {-# LANGUAGE
         MultiParamTypeClasses,
-        FlexibleInstances, FlexibleContexts, 
+        FlexibleInstances, FlexibleContexts,
         IncoherentInstances
   #-}
 
@@ -8,7 +8,7 @@
 
 module Data.Random.Sample where
 
-import Control.Monad.State 
+import Control.Monad.State
 import Data.Random.Distribution
 import Data.Random.Lift
 import Data.Random.RVar
-- 
2.32.0


From 7583073ad112dee683bae892018b0e87a9caa6d1 Mon Sep 17 00:00:00 2001
From: funketh <theodor.k.funke@gmail.com>
Date: Thu, 6 May 2021 19:14:31 +0200
Subject: [PATCH 2/3] fix GHC 9 support by manually expanding TH

---
 random-fu/random-fu.cabal                     |   1 -
 .../src/Data/Random/Distribution/Bernoulli.hs |  78 +++++++----
 .../src/Data/Random/Distribution/Beta.hs      |  13 +-
 .../src/Data/Random/Distribution/Binomial.hs  | 125 +++++++++++++-----
 .../Data/Random/Distribution/Categorical.hs   |   2 -
 .../src/Data/Random/Distribution/Poisson.hs   | 105 +++++++++++----
 .../src/Data/Random/Distribution/Uniform.hs   |  37 ++++--
 random-fu/src/Data/Random/Internal/TH.hs      |  78 -----------
 8 files changed, 267 insertions(+), 172 deletions(-)
 delete mode 100644 random-fu/src/Data/Random/Internal/TH.hs

diff --git a/random-fu/random-fu.cabal b/random-fu/random-fu.cabal
index e7e3db9..e76e464 100644
--- a/random-fu/random-fu.cabal
+++ b/random-fu/random-fu.cabal
@@ -72,7 +72,6 @@ Library
                         Data.Random.Distribution.Ziggurat
                         Data.Random.Internal.Find
                         Data.Random.Internal.Fixed
-                        Data.Random.Internal.TH
                         Data.Random.Lift
                         Data.Random.List
                         Data.Random.RVar
diff --git a/random-fu/src/Data/Random/Distribution/Bernoulli.hs b/random-fu/src/Data/Random/Distribution/Bernoulli.hs
index 1027fd8..c6a3c79 100644
--- a/random-fu/src/Data/Random/Distribution/Bernoulli.hs
+++ b/random-fu/src/Data/Random/Distribution/Bernoulli.hs
@@ -9,14 +9,14 @@
 
 module Data.Random.Distribution.Bernoulli where
 
-import Data.Random.Internal.TH
-
 import Data.Random.RVar
 import Data.Random.Distribution
 import Data.Random.Distribution.Uniform
 
 import Data.Ratio
 import Data.Complex
+import Data.Int
+import Data.Word
 
 -- |Generate a Bernoulli variate with the given probability.  For @Bool@ results,
 -- @bernoulli p@ will return True (p*100)% of the time and False otherwise.
@@ -66,27 +66,59 @@ instance (Distribution (Bernoulli b) Bool, Real b)
     where
         cdf  (Bernoulli p) = boolBernoulliCDF p
 
-$( replicateInstances ''Int integralTypes [d|
-        instance Distribution (Bernoulli b) Bool
-              => Distribution (Bernoulli b) Int
-              where
-                  rvarT (Bernoulli p) = generalBernoulli 0 1 p
-        instance CDF (Bernoulli b) Bool
-              => CDF (Bernoulli b) Int
-              where
-                  cdf  (Bernoulli p) = generalBernoulliCDF (>=) 0 1 p
-    |] )
-
-$( replicateInstances ''Float realFloatTypes [d|
-        instance Distribution (Bernoulli b) Bool
-              => Distribution (Bernoulli b) Float
-              where
-                  rvarT (Bernoulli p) = generalBernoulli 0 1 p
-        instance CDF (Bernoulli b) Bool
-              => CDF (Bernoulli b) Float
-              where
-                  cdf  (Bernoulli p) = generalBernoulliCDF (>=) 0 1 p
-    |] )
+instance Distribution (Bernoulli b) Bool => Distribution (Bernoulli b) Integer where
+    rvarT (Bernoulli p) = generalBernoulli 0 1 p
+instance CDF (Bernoulli b) Bool          => CDF (Bernoulli b) Integer where
+    cdf   (Bernoulli p) = generalBernoulliCDF (>=) 0 1 p
+instance Distribution (Bernoulli b) Bool => Distribution (Bernoulli b) Int where
+    rvarT (Bernoulli p) = generalBernoulli 0 1 p
+instance CDF (Bernoulli b) Bool          => CDF (Bernoulli b) Int where
+    cdf   (Bernoulli p) = generalBernoulliCDF (>=) 0 1 p
+instance Distribution (Bernoulli b) Bool => Distribution (Bernoulli b) Int8 where
+    rvarT (Bernoulli p) = generalBernoulli 0 1 p
+instance CDF (Bernoulli b) Bool          => CDF (Bernoulli b) Int8 where
+    cdf   (Bernoulli p) = generalBernoulliCDF (>=) 0 1 p
+instance Distribution (Bernoulli b) Bool => Distribution (Bernoulli b) Int16 where
+    rvarT (Bernoulli p) = generalBernoulli 0 1 p
+instance CDF (Bernoulli b) Bool          => CDF (Bernoulli b) Int16 where
+    cdf   (Bernoulli p) = generalBernoulliCDF (>=) 0 1 p
+instance Distribution (Bernoulli b) Bool => Distribution (Bernoulli b) Int32 where
+    rvarT (Bernoulli p) = generalBernoulli 0 1 p
+instance CDF (Bernoulli b) Bool          => CDF (Bernoulli b) Int32 where
+    cdf   (Bernoulli p) = generalBernoulliCDF (>=) 0 1 p
+instance Distribution (Bernoulli b) Bool => Distribution (Bernoulli b) Int64 where
+    rvarT (Bernoulli p) = generalBernoulli 0 1 p
+instance CDF (Bernoulli b) Bool          => CDF (Bernoulli b) Int64 where
+    cdf   (Bernoulli p) = generalBernoulliCDF (>=) 0 1 p
+instance Distribution (Bernoulli b) Bool => Distribution (Bernoulli b) Word where
+    rvarT (Bernoulli p) = generalBernoulli 0 1 p
+instance CDF (Bernoulli b) Bool          => CDF (Bernoulli b) Word where
+    cdf   (Bernoulli p) = generalBernoulliCDF (>=) 0 1 p
+instance Distribution (Bernoulli b) Bool => Distribution (Bernoulli b) Word8 where
+    rvarT (Bernoulli p) = generalBernoulli 0 1 p
+instance CDF (Bernoulli b) Bool          => CDF (Bernoulli b) Word8 where
+    cdf   (Bernoulli p) = generalBernoulliCDF (>=) 0 1 p
+instance Distribution (Bernoulli b) Bool => Distribution (Bernoulli b) Word16 where
+    rvarT (Bernoulli p) = generalBernoulli 0 1 p
+instance CDF (Bernoulli b) Bool          => CDF (Bernoulli b) Word16 where
+    cdf   (Bernoulli p) = generalBernoulliCDF (>=) 0 1 p
+instance Distribution (Bernoulli b) Bool => Distribution (Bernoulli b) Word32 where
+    rvarT (Bernoulli p) = generalBernoulli 0 1 p
+instance CDF (Bernoulli b) Bool          => CDF (Bernoulli b) Word32 where
+    cdf   (Bernoulli p) = generalBernoulliCDF (>=) 0 1 p
+instance Distribution (Bernoulli b) Bool => Distribution (Bernoulli b) Word64 where
+    rvarT (Bernoulli p) = generalBernoulli 0 1 p
+instance CDF (Bernoulli b) Bool          => CDF (Bernoulli b) Word64 where
+    cdf   (Bernoulli p) = generalBernoulliCDF (>=) 0 1 p
+
+instance Distribution (Bernoulli b) Bool => Distribution (Bernoulli b) Float where
+    rvarT (Bernoulli p) = generalBernoulli 0 1 p
+instance CDF (Bernoulli b) Bool => CDF (Bernoulli b) Float where
+    cdf   (Bernoulli p) = generalBernoulliCDF (>=) 0 1 p
+instance Distribution (Bernoulli b) Bool => Distribution (Bernoulli b) Double where
+    rvarT (Bernoulli p) = generalBernoulli 0 1 p
+instance CDF (Bernoulli b) Bool => CDF (Bernoulli b) Double where
+    cdf   (Bernoulli p) = generalBernoulliCDF (>=) 0 1 p
 
 instance (Distribution (Bernoulli b) Bool, Integral a)
        => Distribution (Bernoulli b) (Ratio a)
diff --git a/random-fu/src/Data/Random/Distribution/Beta.hs b/random-fu/src/Data/Random/Distribution/Beta.hs
index 754f388..e07b2c0 100644
--- a/random-fu/src/Data/Random/Distribution/Beta.hs
+++ b/random-fu/src/Data/Random/Distribution/Beta.hs
@@ -9,8 +9,6 @@
 
 module Data.Random.Distribution.Beta where
 
-import Data.Random.Internal.TH
-
 import Data.Random.RVar
 import Data.Random.Distribution
 import Data.Random.Distribution.Gamma
@@ -57,7 +55,10 @@ instance PDF Beta Float
   where
     pdf (Beta a b) = realToFrac . exp . logBetaPdf (realToFrac a) (realToFrac b) . realToFrac
 
-$( replicateInstances ''Float realFloatTypes [d|
-        instance Distribution Beta Float
-              where rvarT (Beta a b) = fractionalBeta a b
-    |])
+instance Distribution Beta Float
+  where
+    rvarT (Beta a b) = fractionalBeta a b
+
+instance Distribution Beta Double
+  where
+    rvarT (Beta a b) = fractionalBeta a b
diff --git a/random-fu/src/Data/Random/Distribution/Binomial.hs b/random-fu/src/Data/Random/Distribution/Binomial.hs
index 802a6c8..8495a77 100644
--- a/random-fu/src/Data/Random/Distribution/Binomial.hs
+++ b/random-fu/src/Data/Random/Distribution/Binomial.hs
@@ -9,13 +9,14 @@
 
 module Data.Random.Distribution.Binomial where
 
-import Data.Random.Internal.TH
-
 import Data.Random.RVar
 import Data.Random.Distribution
 import Data.Random.Distribution.Beta
 import Data.Random.Distribution.Uniform
 
+import Data.Int
+import Data.Word
+
 import Numeric.SpecFunctions ( stirlingError )
 import Numeric.SpecFunctions.Extra ( bd0 )
 import Numeric ( log1p )
@@ -131,31 +132,95 @@ binomialT t p = rvarT (Binomial t p)
 
 data Binomial b a = Binomial a b
 
-$( replicateInstances ''Int integralTypes [d|
-        instance ( Floating b, Ord b
-                 , Distribution Beta b
-                 , Distribution StdUniform b
-                 ) => Distribution (Binomial b) Int
-            where
-                rvarT (Binomial t p) = integralBinomial t p
-        instance ( Real b , Distribution (Binomial b) Int
-                 ) => CDF (Binomial b) Int
-            where cdf  (Binomial t p) = integralBinomialCDF t p
-        instance ( Real b , Distribution (Binomial b) Int
-                 ) => PDF (Binomial b) Int
-            where pdf (Binomial t p) = integralBinomialPDF t p
-                  logPdf (Binomial t p) = integralBinomialLogPdf t p
-    |])
-
-$( replicateInstances ''Float realFloatTypes [d|
-        instance Distribution (Binomial b) Integer
-              => Distribution (Binomial b) Float
-              where rvar (Binomial t p) = floatingBinomial t p
-        instance CDF (Binomial b) Integer
-              => CDF (Binomial b) Float
-              where cdf  (Binomial t p) = floatingBinomialCDF t p
-        instance PDF (Binomial b) Integer
-              => PDF (Binomial b) Float
-              where pdf (Binomial t p) = floatingBinomialPDF t p
-                    logPdf (Binomial t p) = floatingBinomialLogPDF t p
-    |])
+instance (Floating b, Ord b, Distribution Beta b, Distribution StdUniform b) => Distribution (Binomial b) Integer where
+    rvarT  (Binomial t p) = integralBinomial t p
+instance (Real b, Distribution (Binomial b) Integer)                         => CDF (Binomial b) Integer where
+    cdf    (Binomial t p) = integralBinomialCDF t p
+instance (Real b, Distribution (Binomial b) Integer)                         => PDF (Binomial b) Integer where
+    pdf    (Binomial t p) = integralBinomialPDF t p
+    logPdf (Binomial t p) = integralBinomialLogPdf t p
+instance (Floating b, Ord b, Distribution Beta b, Distribution StdUniform b) => Distribution (Binomial b) Int where
+    rvarT  (Binomial t p) = integralBinomial t p
+instance (Real b, Distribution (Binomial b) Int)                             => CDF (Binomial b) Int where
+    cdf    (Binomial t p) = integralBinomialCDF t p
+instance (Real b, Distribution (Binomial b) Int)                             => PDF (Binomial b) Int where
+    pdf    (Binomial t p) = integralBinomialPDF t p
+    logPdf (Binomial t p) = integralBinomialLogPdf t p
+instance (Floating b, Ord b, Distribution Beta b, Distribution StdUniform b) => Distribution (Binomial b) Int8 where
+    rvarT  (Binomial t p) = integralBinomial t p
+instance (Real b, Distribution (Binomial b) Int8)                            => CDF (Binomial b) Int8 where
+    cdf    (Binomial t p) = integralBinomialCDF t p
+instance (Real b, Distribution (Binomial b) Int8)                            => PDF (Binomial b) Int8 where
+    pdf    (Binomial t p) = integralBinomialPDF t p
+    logPdf (Binomial t p) = integralBinomialLogPdf t p
+instance (Floating b, Ord b, Distribution Beta b, Distribution StdUniform b) => Distribution (Binomial b) Int16 where
+    rvarT  (Binomial t p) = integralBinomial t p
+instance (Real b, Distribution (Binomial b) Int16)                           => CDF (Binomial b) Int16 where
+    cdf    (Binomial t p) = integralBinomialCDF t p
+instance (Real b, Distribution (Binomial b) Int16)                           => PDF (Binomial b) Int16 where
+    pdf    (Binomial t p) = integralBinomialPDF t p
+    logPdf (Binomial t p) = integralBinomialLogPdf t p
+instance (Floating b, Ord b, Distribution Beta b, Distribution StdUniform b) => Distribution (Binomial b) Int32 where
+    rvarT  (Binomial t p) = integralBinomial t p
+instance (Real b, Distribution (Binomial b) Int32)                           => CDF (Binomial b) Int32 where
+    cdf    (Binomial t p) = integralBinomialCDF t p
+instance (Real b, Distribution (Binomial b) Int32)                           => PDF (Binomial b) Int32 where
+    pdf    (Binomial t p) = integralBinomialPDF t p
+    logPdf (Binomial t p) = integralBinomialLogPdf t p
+instance (Floating b, Ord b, Distribution Beta b, Distribution StdUniform b) => Distribution (Binomial b) Int64 where
+    rvarT  (Binomial t p) = integralBinomial t p
+instance (Real b, Distribution (Binomial b) Int64)                           => CDF (Binomial b) Int64 where
+    cdf    (Binomial t p) = integralBinomialCDF t p
+instance (Real b, Distribution (Binomial b) Int64)                           => PDF (Binomial b) Int64 where
+    pdf    (Binomial t p) = integralBinomialPDF t p
+    logPdf (Binomial t p) = integralBinomialLogPdf t p
+instance (Floating b, Ord b, Distribution Beta b, Distribution StdUniform b) => Distribution (Binomial b) Word where
+    rvarT  (Binomial t p) = integralBinomial t p
+instance (Real b, Distribution (Binomial b) Word)                            => CDF (Binomial b) Word where
+    cdf    (Binomial t p) = integralBinomialCDF t p
+instance (Real b, Distribution (Binomial b) Word)                            => PDF (Binomial b) Word where
+    pdf    (Binomial t p) = integralBinomialPDF t p
+    logPdf (Binomial t p) = integralBinomialLogPdf t p
+instance (Floating b, Ord b, Distribution Beta b, Distribution StdUniform b) => Distribution (Binomial b) Word8 where
+    rvarT  (Binomial t p) = integralBinomial t p
+instance (Real b, Distribution (Binomial b) Word8)                           => CDF (Binomial b) Word8 where
+    cdf    (Binomial t p) = integralBinomialCDF t p
+instance (Real b, Distribution (Binomial b) Word8)                           => PDF (Binomial b) Word8 where
+    pdf    (Binomial t p) = integralBinomialPDF t p
+    logPdf (Binomial t p) = integralBinomialLogPdf t p
+instance (Floating b, Ord b, Distribution Beta b, Distribution StdUniform b) => Distribution (Binomial b) Word16 where
+    rvarT  (Binomial t p) = integralBinomial t p
+instance (Real b, Distribution (Binomial b) Word16)                          => CDF (Binomial b) Word16 where
+    cdf    (Binomial t p) = integralBinomialCDF t p
+instance (Real b, Distribution (Binomial b) Word16)                          => PDF (Binomial b) Word16 where
+    pdf    (Binomial t p) = integralBinomialPDF t p
+    logPdf (Binomial t p) = integralBinomialLogPdf t p
+instance (Floating b, Ord b, Distribution Beta b, Distribution StdUniform b) => Distribution (Binomial b) Word32 where
+    rvarT  (Binomial t p) = integralBinomial t p
+instance (Real b, Distribution (Binomial b) Word32)                          => CDF (Binomial b) Word32 where
+    cdf    (Binomial t p) = integralBinomialCDF t p
+instance (Real b, Distribution (Binomial b) Word32)                          => PDF (Binomial b) Word32 where
+    pdf    (Binomial t p) = integralBinomialPDF t p
+    logPdf (Binomial t p) = integralBinomialLogPdf t p
+instance (Floating b, Ord b, Distribution Beta b, Distribution StdUniform b) => Distribution (Binomial b) Word64 where
+    rvarT  (Binomial t p) = integralBinomial t p
+instance (Real b, Distribution (Binomial b) Word64)                          => CDF (Binomial b) Word64 where
+    cdf    (Binomial t p) = integralBinomialCDF t p
+instance (Real b, Distribution (Binomial b) Word64)                          => PDF (Binomial b) Word64 where
+    pdf    (Binomial t p) = integralBinomialPDF t p
+    logPdf (Binomial t p) = integralBinomialLogPdf t p
+
+instance Distribution (Binomial b) Integer => Distribution (Binomial b) Float where
+    rvar   (Binomial t p) = floatingBinomial t p
+instance CDF (Binomial b) Integer          => CDF (Binomial b) Float where
+    cdf    (Binomial t p) = floatingBinomialCDF t p
+instance PDF (Binomial b) Integer          => PDF (Binomial b) Float where
+    pdf    (Binomial t p) = floatingBinomialPDF t p
+    logPdf (Binomial t p) = floatingBinomialLogPDF t p
+instance Distribution (Binomial b) Integer => Distribution (Binomial b) Double where
+    rvar   (Binomial t p) = floatingBinomial t p
+instance CDF (Binomial b) Integer          => CDF (Binomial b) Double where
+    cdf    (Binomial t p) = floatingBinomialCDF t p
+instance PDF (Binomial b) Integer          => PDF (Binomial b) Double where
+    pdf    (Binomial t p) = floatingBinomialPDF t p
+    logPdf (Binomial t p) = floatingBinomialLogPDF t p
diff --git a/random-fu/src/Data/Random/Distribution/Categorical.hs b/random-fu/src/Data/Random/Distribution/Categorical.hs
index 575a0a2..9980a4c 100644
--- a/random-fu/src/Data/Random/Distribution/Categorical.hs
+++ b/random-fu/src/Data/Random/Distribution/Categorical.hs
@@ -23,9 +23,7 @@ import Data.Random.Distribution.Uniform
 import Control.Arrow
 import Control.Monad
 import Control.Monad.ST
-import Data.Foldable (Foldable(foldMap))
 import Data.STRef
-import Data.Traversable (Traversable(traverse, sequenceA))
 
 import Data.List
 import Data.Function
diff --git a/random-fu/src/Data/Random/Distribution/Poisson.hs b/random-fu/src/Data/Random/Distribution/Poisson.hs
index 81bbec6..2613f49 100644
--- a/random-fu/src/Data/Random/Distribution/Poisson.hs
+++ b/random-fu/src/Data/Random/Distribution/Poisson.hs
@@ -8,8 +8,6 @@
 
 module Data.Random.Distribution.Poisson where
 
-import Data.Random.Internal.TH
-
 import Data.Random.RVar
 import Data.Random.Distribution
 import Data.Random.Distribution.Uniform
@@ -18,6 +16,9 @@ import Data.Random.Distribution.Binomial
 
 import Control.Monad
 
+import Data.Int
+import Data.Word
+
 -- from Knuth, with interpretation help from gsl sources
 integralPoisson :: (Integral a, RealFloat b, Distribution StdUniform b, Distribution (Erlang a) b, Distribution (Binomial b) a) => b -> RVarT m a
 integralPoisson = psn 0
@@ -87,24 +88,82 @@ poissonT mu = rvarT (Poisson mu)
 
 newtype Poisson b a = Poisson b
 
-$( replicateInstances ''Int integralTypes [d|
-        instance ( RealFloat b
-                 , Distribution StdUniform   b
-                 , Distribution (Erlang Int) b
-                 , Distribution (Binomial b) Int
-                 ) => Distribution (Poisson b) Int where
-            rvarT (Poisson mu) = integralPoisson mu
-        instance (Real b, Distribution (Poisson b) Int) => CDF (Poisson b) Int where
-            cdf  (Poisson mu) = integralPoissonCDF mu
-        instance (Real b, Distribution (Poisson b) Int) => PDF (Poisson b) Int where
-            pdf  (Poisson mu) = integralPoissonPDF mu
-    |] )
-
-$( replicateInstances ''Float realFloatTypes [d|
-        instance (Distribution (Poisson b) Integer) => Distribution (Poisson b) Float where
-            rvarT (Poisson mu) = fractionalPoisson mu
-        instance (CDF (Poisson b) Integer) => CDF (Poisson b) Float where
-            cdf  (Poisson mu) = fractionalPoissonCDF mu
-        instance (PDF (Poisson b) Integer) => PDF (Poisson b) Float where
-            pdf  (Poisson mu) = fractionalPoissonPDF mu
-    |])
+instance (RealFloat b, Distribution StdUniform b, Distribution (Erlang Integer) b, Distribution (Binomial b) Integer) => Distribution (Poisson b) Integer where
+    rvarT (Poisson mu) = integralPoisson mu
+instance (Real b, Distribution (Poisson b) Integer) => CDF (Poisson b) Integer where
+    cdf   (Poisson mu) = integralPoissonCDF mu
+instance (Real b, Distribution (Poisson b) Integer) => PDF (Poisson b) Integer where
+    pdf   (Poisson mu) = integralPoissonPDF mu
+instance (RealFloat b, Distribution StdUniform b, Distribution (Erlang Int) b, Distribution (Binomial b) Int) => Distribution (Poisson b) Int where
+    rvarT (Poisson mu) = integralPoisson mu
+instance (Real b, Distribution (Poisson b) Int) => CDF (Poisson b) Int where
+    cdf   (Poisson mu) = integralPoissonCDF mu
+instance (Real b, Distribution (Poisson b) Int) => PDF (Poisson b) Int where
+    pdf   (Poisson mu) = integralPoissonPDF mu
+instance (RealFloat b, Distribution StdUniform b, Distribution (Erlang Int8) b, Distribution (Binomial b) Int8) => Distribution (Poisson b) Int8 where
+    rvarT (Poisson mu) = integralPoisson mu
+instance (Real b, Distribution (Poisson b) Int8) => CDF (Poisson b) Int8 where
+    cdf   (Poisson mu) = integralPoissonCDF mu
+instance (Real b, Distribution (Poisson b) Int8) => PDF (Poisson b) Int8 where
+    pdf   (Poisson mu) = integralPoissonPDF mu
+instance (RealFloat b, Distribution StdUniform b, Distribution (Erlang Int16) b, Distribution (Binomial b) Int16) => Distribution (Poisson b) Int16 where
+    rvarT (Poisson mu) = integralPoisson mu
+instance (Real b, Distribution (Poisson b) Int16) => CDF (Poisson b) Int16 where
+    cdf   (Poisson mu) = integralPoissonCDF mu
+instance (Real b, Distribution (Poisson b) Int16) => PDF (Poisson b) Int16 where
+    pdf   (Poisson mu) = integralPoissonPDF mu
+instance (RealFloat b, Distribution StdUniform b, Distribution (Erlang Int32) b, Distribution (Binomial b) Int32) => Distribution (Poisson b) Int32 where
+    rvarT (Poisson mu) = integralPoisson mu
+instance (Real b, Distribution (Poisson b) Int32) => CDF (Poisson b) Int32 where
+    cdf   (Poisson mu) = integralPoissonCDF mu
+instance (Real b, Distribution (Poisson b) Int32) => PDF (Poisson b) Int32 where
+    pdf   (Poisson mu) = integralPoissonPDF mu
+instance (RealFloat b, Distribution StdUniform b, Distribution (Erlang Int64) b, Distribution (Binomial b) Int64) => Distribution (Poisson b) Int64 where
+    rvarT (Poisson mu) = integralPoisson mu
+instance (Real b, Distribution (Poisson b) Int64) => CDF (Poisson b) Int64 where
+    cdf   (Poisson mu) = integralPoissonCDF mu
+instance (Real b, Distribution (Poisson b) Int64) => PDF (Poisson b) Int64 where
+    pdf   (Poisson mu) = integralPoissonPDF mu
+instance (RealFloat b, Distribution StdUniform b, Distribution (Erlang Word) b, Distribution (Binomial b) Word) => Distribution (Poisson b) Word where
+    rvarT (Poisson mu) = integralPoisson mu
+instance (Real b, Distribution (Poisson b) Word) => CDF (Poisson b) Word where
+    cdf   (Poisson mu) = integralPoissonCDF mu
+instance (Real b, Distribution (Poisson b) Word) => PDF (Poisson b) Word where
+    pdf   (Poisson mu) = integralPoissonPDF mu
+instance (RealFloat b, Distribution StdUniform b, Distribution (Erlang Word8) b, Distribution (Binomial b) Word8) => Distribution (Poisson b) Word8 where
+    rvarT (Poisson mu) = integralPoisson mu
+instance (Real b, Distribution (Poisson b) Word8) => CDF (Poisson b) Word8 where
+    cdf   (Poisson mu) = integralPoissonCDF mu
+instance (Real b, Distribution (Poisson b) Word8) => PDF (Poisson b) Word8 where
+    pdf   (Poisson mu) = integralPoissonPDF mu
+instance (RealFloat b, Distribution StdUniform b, Distribution (Erlang Word16) b, Distribution (Binomial b) Word16) => Distribution (Poisson b) Word16 where
+    rvarT (Poisson mu) = integralPoisson mu
+instance (Real b, Distribution (Poisson b) Word16) => CDF (Poisson b) Word16 where
+    cdf   (Poisson mu) = integralPoissonCDF mu
+instance (Real b, Distribution (Poisson b) Word16) => PDF (Poisson b) Word16 where
+    pdf   (Poisson mu) = integralPoissonPDF mu
+instance (RealFloat b, Distribution StdUniform b, Distribution (Erlang Word32) b, Distribution (Binomial b) Word32) => Distribution (Poisson b) Word32 where
+    rvarT (Poisson mu) = integralPoisson mu
+instance (Real b, Distribution (Poisson b) Word32) => CDF (Poisson b) Word32 where
+    cdf   (Poisson mu) = integralPoissonCDF mu
+instance (Real b, Distribution (Poisson b) Word32) => PDF (Poisson b) Word32 where
+    pdf   (Poisson mu) = integralPoissonPDF mu
+instance (RealFloat b, Distribution StdUniform b, Distribution (Erlang Word64) b, Distribution (Binomial b) Word64) => Distribution (Poisson b) Word64 where
+    rvarT (Poisson mu) = integralPoisson mu
+instance (Real b, Distribution (Poisson b) Word64) => CDF (Poisson b) Word64 where
+    cdf   (Poisson mu) = integralPoissonCDF mu
+instance (Real b, Distribution (Poisson b) Word64) => PDF (Poisson b) Word64 where
+    pdf   (Poisson mu) = integralPoissonPDF mu
+
+instance Distribution (Poisson b) Integer => Distribution (Poisson b) Float where
+    rvarT (Poisson mu) = fractionalPoisson mu
+instance CDF (Poisson b) Integer          => CDF (Poisson b) Float where
+    cdf   (Poisson mu) = fractionalPoissonCDF mu
+instance PDF (Poisson b) Integer          => PDF (Poisson b) Float where
+    pdf   (Poisson mu) = fractionalPoissonPDF mu
+instance Distribution (Poisson b) Integer => Distribution (Poisson b) Double where
+    rvarT (Poisson mu) = fractionalPoisson mu
+instance CDF (Poisson b) Integer          => CDF (Poisson b) Double where
+    cdf   (Poisson mu) = fractionalPoissonCDF mu
+instance PDF (Poisson b) Integer          => PDF (Poisson b) Double where
+    pdf   (Poisson mu) = fractionalPoissonPDF mu
diff --git a/random-fu/src/Data/Random/Distribution/Uniform.hs b/random-fu/src/Data/Random/Distribution/Uniform.hs
index a580fe8..74dd89a 100644
--- a/random-fu/src/Data/Random/Distribution/Uniform.hs
+++ b/random-fu/src/Data/Random/Distribution/Uniform.hs
@@ -37,7 +37,6 @@ module Data.Random.Distribution.Uniform
     , enumUniformCDF
     ) where
 
-import Data.Random.Internal.TH
 import Data.Random.Internal.Words
 import Data.Random.Internal.Fixed
 
@@ -284,10 +283,28 @@ data Uniform t =
 -- (that is, 0 to 1 including 0 but not including 1).
 data StdUniform t = StdUniform
 
-$( replicateInstances ''Int integralTypes [d|
-        instance Distribution Uniform Int   where rvarT (Uniform a b) = integralUniform a b
-        instance CDF Uniform Int            where cdf   (Uniform a b) = integralUniformCDF a b
-    |])
+instance Distribution Uniform Integer where rvarT (Uniform a b) = integralUniform a b
+instance CDF Uniform Integer          where cdf   (Uniform a b) = integralUniformCDF a b
+instance Distribution Uniform Int     where rvarT (Uniform a b) = integralUniform a b
+instance CDF Uniform Int              where cdf   (Uniform a b) = integralUniformCDF a b
+instance Distribution Uniform Int8    where rvarT (Uniform a b) = integralUniform a b
+instance CDF Uniform Int8             where cdf   (Uniform a b) = integralUniformCDF a b
+instance Distribution Uniform Int16   where rvarT (Uniform a b) = integralUniform a b
+instance CDF Uniform Int16            where cdf   (Uniform a b) = integralUniformCDF a b
+instance Distribution Uniform Int32   where rvarT (Uniform a b) = integralUniform a b
+instance CDF Uniform Int32            where cdf   (Uniform a b) = integralUniformCDF a b
+instance Distribution Uniform Int64   where rvarT (Uniform a b) = integralUniform a b
+instance CDF Uniform Int64            where cdf   (Uniform a b) = integralUniformCDF a b
+instance Distribution Uniform Word    where rvarT (Uniform a b) = integralUniform a b
+instance CDF Uniform Word             where cdf   (Uniform a b) = integralUniformCDF a b
+instance Distribution Uniform Word8   where rvarT (Uniform a b) = integralUniform a b
+instance CDF Uniform Word8            where cdf   (Uniform a b) = integralUniformCDF a b
+instance Distribution Uniform Word16  where rvarT (Uniform a b) = integralUniform a b
+instance CDF Uniform Word16           where cdf   (Uniform a b) = integralUniformCDF a b
+instance Distribution Uniform Word32  where rvarT (Uniform a b) = integralUniform a b
+instance CDF Uniform Word32           where cdf   (Uniform a b) = integralUniformCDF a b
+instance Distribution Uniform Word64  where rvarT (Uniform a b) = integralUniform a b
+instance CDF Uniform Word64           where cdf   (Uniform a b) = integralUniformCDF a b
 
 instance Distribution StdUniform Word8      where rvarT _ = getRandomWord8
 instance Distribution StdUniform Word16     where rvarT _ = getRandomWord16
@@ -349,11 +366,13 @@ instance HasResolution r =>
 
 instance Distribution Uniform ()            where rvarT (Uniform _ _) = return ()
 instance CDF Uniform ()                     where cdf   (Uniform _ _) = return 1
-$( replicateInstances ''Char [''Char, ''Bool, ''Ordering] [d|
-        instance Distribution Uniform Char  where rvarT (Uniform a b) = enumUniform a b
-        instance CDF Uniform Char           where cdf   (Uniform a b) = enumUniformCDF a b
 
-    |])
+instance Distribution Uniform Char     where rvarT (Uniform a b) = enumUniform a b
+instance CDF Uniform Char              where cdf   (Uniform a b) = enumUniformCDF a b
+instance Distribution Uniform Bool     where rvarT (Uniform a b) = enumUniform a b
+instance CDF Uniform Bool              where cdf   (Uniform a b) = enumUniformCDF a b
+instance Distribution Uniform Ordering where rvarT (Uniform a b) = enumUniform a b
+instance CDF Uniform Ordering          where cdf   (Uniform a b) = enumUniformCDF a b
 
 instance Distribution StdUniform ()         where rvarT ~StdUniform = return ()
 instance CDF StdUniform ()                  where cdf   ~StdUniform = return 1
diff --git a/random-fu/src/Data/Random/Internal/TH.hs b/random-fu/src/Data/Random/Internal/TH.hs
deleted file mode 100644
index 500b75b..0000000
--- a/random-fu/src/Data/Random/Internal/TH.hs
+++ /dev/null
@@ -1,78 +0,0 @@
-{-# LANGUAGE
-        TemplateHaskell
-  #-}
-
--- |Template Haskell utility code to replicate instance declarations
--- to cover large numbers of types.  I'm doing that rather than using
--- class contexts because most Distribution instances need to cover
--- multiple classes (such as Enum, Integral and Fractional) and that
--- can't be done easily because of overlap.
---
--- I experimented a bit with a convoluted type-level classification
--- scheme, but I think this is simpler and easier to understand.  It
--- makes the haddock docs more cluttered because of the combinatorial
--- explosion of instances, but overall I think it's just more sane than
--- anything else I've come up with yet.
-module Data.Random.Internal.TH
-    ( replicateInstances
-    , integralTypes, realFloatTypes
-    ) where
-
-import Data.Generics
-import Language.Haskell.TH
-
-import Data.Word
-import Data.Int
-import Control.Monad
-
--- |Names of standard 'Integral' types
-integralTypes :: [Name]
-integralTypes =
-    [ ''Integer
-    , ''Int,  ''Int8,  ''Int16,  ''Int32,  ''Int64
-    , ''Word, ''Word8, ''Word16, ''Word32, ''Word64
-    ]
-
--- |Names of standard 'RealFloat' types
-realFloatTypes :: [Name]
-realFloatTypes =
-    [ ''Float, ''Double ]
-
--- @replaceName x y@ is a function that will
--- replace @x@ with @y@ whenever it sees it.  That is:
---
--- > replaceName x y x  ==>  y
--- > replaceName x y z  ==>  z
---  (@z /= x@)
-replaceName :: Name -> Name -> Name -> Name
-replaceName x y z
-    | x == z    = y
-    | otherwise = z
-
--- | @replicateInstances standin types decls@ will take the template-haskell
--- 'Dec's in @decls@ and substitute every instance of the 'Name' @standin@ with
--- each 'Name' in @types@, producing one copy of the 'Dec's in @decls@ for every
--- 'Name' in @types@.
---
--- For example, 'Data.Random.Distribution.Uniform' has the following bit of TH code:
---
--- @ $( replicateInstances ''Int integralTypes [d|                                                  @
---
--- @       instance Distribution Uniform Int   where rvar (Uniform a b) = integralUniform a b       @
---
--- @       instance CDF Uniform Int            where cdf  (Uniform a b) = integralUniformCDF a b    @
---
--- @   |])                                                                                          @
---
--- This code takes those 2 instance declarations and creates identical ones for
--- every type named in 'integralTypes'.
-replicateInstances :: (Monad m, Data t) => Name -> [Name] -> m [t] -> m [t]
-replicateInstances standin types getDecls = liftM concat $ sequence
-    [ do
-        decls <- getDecls
-        sequence
-            [ everywhereM (mkM (return . replaceName standin t)) dec
-            | dec <- decls
-            ]
-    | t <- types
-    ]
-- 
2.32.0


From 2d38294582ba211df6a5a2b7f7a2c5e71038b0e7 Mon Sep 17 00:00:00 2001
From: funketh <theodor.k.funke@gmail.com>
Date: Fri, 7 May 2021 12:10:40 +0200
Subject: [PATCH 3/3] remove redundant TemplateHaskell LANGUAGE pragmas

---
 random-fu/src/Data/Random/Distribution/Bernoulli.hs | 3 +--
 random-fu/src/Data/Random/Distribution/Beta.hs      | 3 +--
 random-fu/src/Data/Random/Distribution/Binomial.hs  | 2 +-
 random-fu/src/Data/Random/Distribution/Poisson.hs   | 3 +--
 4 files changed, 4 insertions(+), 7 deletions(-)

diff --git a/random-fu/src/Data/Random/Distribution/Bernoulli.hs b/random-fu/src/Data/Random/Distribution/Bernoulli.hs
index c6a3c79..8d219e0 100644
--- a/random-fu/src/Data/Random/Distribution/Bernoulli.hs
+++ b/random-fu/src/Data/Random/Distribution/Bernoulli.hs
@@ -1,8 +1,7 @@
 {-# LANGUAGE
     MultiParamTypeClasses,
     FlexibleInstances, FlexibleContexts,
-    UndecidableInstances,
-    TemplateHaskell
+    UndecidableInstances
   #-}
 
 {-# OPTIONS_GHC -fno-warn-simplifiable-class-constraints #-}
diff --git a/random-fu/src/Data/Random/Distribution/Beta.hs b/random-fu/src/Data/Random/Distribution/Beta.hs
index e07b2c0..2e48258 100644
--- a/random-fu/src/Data/Random/Distribution/Beta.hs
+++ b/random-fu/src/Data/Random/Distribution/Beta.hs
@@ -1,8 +1,7 @@
 {-# LANGUAGE
     MultiParamTypeClasses,
     FlexibleInstances, FlexibleContexts,
-    UndecidableInstances,
-    TemplateHaskell
+    UndecidableInstances
   #-}
 
 {-# OPTIONS_GHC -fno-warn-simplifiable-class-constraints #-}
diff --git a/random-fu/src/Data/Random/Distribution/Binomial.hs b/random-fu/src/Data/Random/Distribution/Binomial.hs
index 8495a77..ff394b4 100644
--- a/random-fu/src/Data/Random/Distribution/Binomial.hs
+++ b/random-fu/src/Data/Random/Distribution/Binomial.hs
@@ -1,7 +1,7 @@
 {-# LANGUAGE
     MultiParamTypeClasses,
     FlexibleInstances, FlexibleContexts,
-    UndecidableInstances, TemplateHaskell,
+    UndecidableInstances,
     BangPatterns
   #-}
 
diff --git a/random-fu/src/Data/Random/Distribution/Poisson.hs b/random-fu/src/Data/Random/Distribution/Poisson.hs
index 2613f49..a7c2cb4 100644
--- a/random-fu/src/Data/Random/Distribution/Poisson.hs
+++ b/random-fu/src/Data/Random/Distribution/Poisson.hs
@@ -1,7 +1,6 @@
 {-# LANGUAGE
     MultiParamTypeClasses,
-    FlexibleInstances, FlexibleContexts, UndecidableInstances,
-    TemplateHaskell
+    FlexibleInstances, FlexibleContexts, UndecidableInstances
   #-}
 
 {-# OPTIONS_GHC -fno-warn-simplifiable-class-constraints #-}
-- 
2.32.0

