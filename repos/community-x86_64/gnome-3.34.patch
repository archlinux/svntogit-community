From a494b8e799715ddf934ff4bd92a358a66204eb83 Mon Sep 17 00:00:00 2001
From: Benjamin Berg <bberg@redhat.com>
Date: Fri, 13 Sep 2019 17:00:27 +0200
Subject: [PATCH] vdagentd: Fix session lookup for new GNOME versions

New GNOME versions have started to manage the session using the systemd
user instance. The effect of this is that the spice-vdagent running in
the user session is forked off (indirectly) from the systemd user
instance and does technically not belong to any session.

The correct way of handling this situation is to simply assume that the
process belongs to the users graphical session. Add a heuristic to find
the graphical session based on the UID, fixing spice-vdagent running on
GNOME 3.34 with systemd integration.
---
 src/vdagentd/systemd-login.c | 58 +++++++++++++++++++++++++++++++++---
 1 file changed, 54 insertions(+), 4 deletions(-)

diff --git a/src/vdagentd/systemd-login.c b/src/vdagentd/systemd-login.c
index a11b66d..2e237ae 100644
--- a/src/vdagentd/systemd-login.c
+++ b/src/vdagentd/systemd-login.c
@@ -286,15 +286,65 @@ const char *session_info_get_active_session(struct session_info *si)
 
 char *session_info_session_for_pid(struct session_info *si, uint32_t pid)
 {
+    int i;
     int r;
+    GStrv sessions = NULL;
     char *session = NULL;
+    uid_t uid;
 
     r = sd_pid_get_session(pid, &session);
-    if (r < 0)
-        syslog(LOG_ERR, "Error getting session for pid %u: %s",
-                pid, strerror(-r));
-    else if (si->verbose)
+    if (r >= 0)
+        goto out;
+
+    /* If we could not get a session for the pid then the agent is probably
+     * running in a systemd managed session. In that case we simply assume
+     * it is actually part of the newest graphical session we can find. */
+    r = sd_pid_get_owner_uid(pid, &uid);
+    if (r < 0) {
+        syslog(LOG_ERR, "Error getting owner UID for pid %u: %s",
+               pid, strerror(-r));
+        goto out;
+    }
+
+    r = sd_uid_get_sessions(uid, 0, &sessions);
+    if (r < 0) {
+        syslog(LOG_ERR, "Error getting sessions for UID %d: %s",
+               (int) uid, strerror(-r));
+        goto out;
+    }
+
+    for (i = 0; sessions[i] != NULL; i++) {
+        char *session_type = NULL;
+
+        r = sd_session_get_type(sessions[i], &session_type);
+
+        if (r < 0) {
+            syslog(LOG_ERR, "Error getting session type for session %s: %s",
+                   sessions[i], strerror(-r));
+            continue;
+        }
+
+        if (g_strcmp0(session_type, "wayland") == 0 ||
+            g_strcmp0(session_type, "x11") == 0 ||
+            g_strcmp0(session_type, "mir") == 0) {
+
+            /* We prefer the newest session (i.e. last entry) from the
+             * user, assuming that any old session that still exist has
+             * just not yet died properly. */
+            if (session != NULL)
+                free (session);
+            session = g_strdup(sessions[i]);
+        }
+
+        free(session_type);
+    }
+
+    g_strfreev(sessions);
+
+out:
+    if (session != NULL && si->verbose) {
         syslog(LOG_INFO, "Session for pid %u: %s", pid, session);
+    }
 
     return session;
 }
-- 
2.22.0

